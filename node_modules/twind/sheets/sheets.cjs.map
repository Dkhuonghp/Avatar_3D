{
  "version": 3,
  "sources": ["../../src/sheets/index.ts", "../../src/internal/dom.ts", "../../src/sheets/index.ts"],
  "sourcesContent": ["import type { SheetConfig, Sheet, SheetInit, SheetInitCallback } from '../types'\nimport { getStyleElement, STYLE_ELEMENT_ID } from '../internal/dom'\n\n/**\n * Creates an sheet which inserts style rules through the Document Object Model.\n */\nexport const domSheet = ({\n  nonce,\n  target = getStyleElement(nonce),\n}: SheetConfig<HTMLStyleElement> = {}): Sheet<HTMLStyleElement> => ({\n  target,\n  insert: (rule, index) => {\n    target.insertBefore(document.createTextNode(rule), target.childNodes[index])\n  },\n})\n\n/**\n * Allows to reset and snaphot the current state of an sheet and\n * in extension the internal mutable state (caches, ...) of `tw`.\n */\nexport interface Storage {\n  /**\n   * Register a function that should be called to create a new state.\n   */\n  init: SheetInit\n\n  /**\n   * Creates a snapshot of the current state, invokes all init callbacks to create a fresh state\n   * and returns the snaphot.\n   */\n  reset: (snapshot?: unknown[] | undefined) => unknown[]\n}\n\nconst createStorage = (): Storage => {\n  const callbacks: SheetInitCallback[] = []\n  let state: unknown[] = []\n\n  const invoke = <T>(callback: SheetInitCallback<T>, index: number): T =>\n    (state[index] = callback(state[index] as T))\n\n  return {\n    init: (callback) => invoke(callback, callbacks.push(callback as SheetInitCallback) - 1),\n    reset: (snapshot = []) => {\n      // eslint-disable-next-line @typescript-eslint/no-extra-semi\n      ;[snapshot, state] = [state, snapshot]\n      callbacks.forEach(invoke)\n      return snapshot\n    },\n  }\n}\n\nexport interface VirtualSheet extends Sheet<string[]>, Storage {\n  init: SheetInit\n}\n\n/**\n * Creates an sheet which collects style rules into an array.\n */\nexport const virtualSheet = (): VirtualSheet => {\n  const storage = createStorage()\n\n  let target: string[]\n  storage.init<string[]>((value = []) => (target = value))\n\n  return {\n    ...storage,\n    get target() {\n      return [...target]\n    },\n    insert: (rule, index) => target.splice(index, 0, rule),\n  }\n}\n\nexport interface StyleTagProperties {\n  id: string\n  textContent: string\n}\n\nexport interface HasTarget {\n  readonly target: readonly string[]\n}\n\nexport type StyleTagSheet = HasTarget | readonly string[]\n\n/**\n * Transforms css rules into `<style>` tag properties.\n */\nexport const getStyleTagProperties = (sheet: StyleTagSheet): StyleTagProperties => ({\n  id: STYLE_ELEMENT_ID,\n  textContent: (Array.isArray(sheet) ? sheet : (sheet as HasTarget).target).join(''),\n})\n\n/**\n * Transforms css rules into a `<style>` tag string.\n */\nexport const getStyleTag = (sheet: StyleTagSheet, attributes?: Record<string, string>): string => {\n  const { id, textContent } = getStyleTagProperties(sheet)\n\n  attributes = { ...attributes, id }\n\n  return `<style${Object.keys(attributes).reduce(\n    (attrs, key) =>\n      `${attrs} ${key}=${JSON.stringify((attributes as Record<string, string>)[key])}`,\n    '',\n  )}>${textContent}</style>`\n}\n", "export const STYLE_ELEMENT_ID = '__twind' as const\n\ndeclare global {\n  interface Window {\n    [STYLE_ELEMENT_ID]?: HTMLStyleElement\n  }\n}\n\nexport const getStyleElement = (nonce?: string): HTMLStyleElement => {\n  // Hydrate existing style element if available\n  // self[id] - every element with an id is available through the global object\n  // eslint-disable-next-line no-restricted-globals\n  let element = self[STYLE_ELEMENT_ID]\n\n  if (!element) {\n    // Create a new one otherwise\n    element = document.head.appendChild(document.createElement('style'))\n\n    element.id = STYLE_ELEMENT_ID\n    nonce && (element.nonce = nonce)\n\n    // Avoid Edge bug where empty style elements doesn't create sheets\n    element.appendChild(document.createTextNode(''))\n  }\n\n  return element\n}\n", "import type { SheetConfig, Sheet, SheetInit, SheetInitCallback } from '../types'\nimport { getStyleElement, STYLE_ELEMENT_ID } from '../internal/dom'\n\n/**\n * Creates an sheet which inserts style rules through the Document Object Model.\n */\nexport const domSheet = ({\n  nonce,\n  target = getStyleElement(nonce),\n}: SheetConfig<HTMLStyleElement> = {}): Sheet<HTMLStyleElement> => ({\n  target,\n  insert: (rule, index) => {\n    target.insertBefore(document.createTextNode(rule), target.childNodes[index])\n  },\n})\n\n/**\n * Allows to reset and snaphot the current state of an sheet and\n * in extension the internal mutable state (caches, ...) of `tw`.\n */\nexport interface Storage {\n  /**\n   * Register a function that should be called to create a new state.\n   */\n  init: SheetInit\n\n  /**\n   * Creates a snapshot of the current state, invokes all init callbacks to create a fresh state\n   * and returns the snaphot.\n   */\n  reset: (snapshot?: unknown[] | undefined) => unknown[]\n}\n\nconst createStorage = (): Storage => {\n  const callbacks: SheetInitCallback[] = []\n  let state: unknown[] = []\n\n  const invoke = <T>(callback: SheetInitCallback<T>, index: number): T =>\n    (state[index] = callback(state[index] as T))\n\n  return {\n    init: (callback) => invoke(callback, callbacks.push(callback as SheetInitCallback) - 1),\n    reset: (snapshot = []) => {\n      // eslint-disable-next-line @typescript-eslint/no-extra-semi\n      ;[snapshot, state] = [state, snapshot]\n      callbacks.forEach(invoke)\n      return snapshot\n    },\n  }\n}\n\nexport interface VirtualSheet extends Sheet<string[]>, Storage {\n  init: SheetInit\n}\n\n/**\n * Creates an sheet which collects style rules into an array.\n */\nexport const virtualSheet = (): VirtualSheet => {\n  const storage = createStorage()\n\n  let target: string[]\n  storage.init<string[]>((value = []) => (target = value))\n\n  return {\n    ...storage,\n    get target() {\n      return [...target]\n    },\n    insert: (rule, index) => target.splice(index, 0, rule),\n  }\n}\n\nexport interface StyleTagProperties {\n  id: string\n  textContent: string\n}\n\nexport interface HasTarget {\n  readonly target: readonly string[]\n}\n\nexport type StyleTagSheet = HasTarget | readonly string[]\n\n/**\n * Transforms css rules into `<style>` tag properties.\n */\nexport const getStyleTagProperties = (sheet: StyleTagSheet): StyleTagProperties => ({\n  id: STYLE_ELEMENT_ID,\n  textContent: (Array.isArray(sheet) ? sheet : (sheet as HasTarget).target).join(''),\n})\n\n/**\n * Transforms css rules into a `<style>` tag string.\n */\nexport const getStyleTag = (sheet: StyleTagSheet, attributes?: Record<string, string>): string => {\n  const { id, textContent } = getStyleTagProperties(sheet)\n\n  attributes = { ...attributes, id }\n\n  return `<style${Object.keys(attributes).reduce(\n    (attrs, key) =>\n      `${attrs} ${key}=${JSON.stringify((attributes as Record<string, string>)[key])}`,\n    '',\n  )}>${textContent}</style>`\n}\n"],
  "mappings": ";;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAO,IAAM,mBAAmB;AAQzB,sBAAwB;AAI7B,gBAAc,KAAK;AAEnB,MAAI,CAAC;AAEH,cAAU,SAAS,KAAK,YAAY,SAAS,cAAc;AAE3D,YAAQ,KAAK;AACb,aAAU,SAAQ,QAAQ;AAG1B,YAAQ,YAAY,SAAS,eAAe;AAAA;AAG9C,SAAO;AAAA;;;ACnBF,IAAM,WAAW;AAAA,EACtB;AAAA,EACA,SAAS,gBAAgB;AAAA,IACQ,OAAiC;AAAA,EAClE;AAAA,EACA,QAAQ;AACN,WAAO,aAAa,SAAS,eAAe,OAAO,OAAO,WAAW;AAAA;AAAA;AAqBzE,oBAAsB;AACpB,oBAAuC;AACvC,cAAuB;AAEvB,iBAAe,qBACZ,MAAM,SAAS,SAAS,MAAM;AAEjC,SAAO;AAAA,IACL,MAAM,cAAc,OAAO,UAAU,UAAU,KAAK,YAAiC;AAAA,IACrF,OAAO,YAAY;AAEjB;AAAC,OAAC,UAAU,SAAS,CAAC,OAAO;AAC7B,gBAAU,QAAQ;AAClB,aAAO;AAAA;AAAA;AAAA;AAYN,mBAAqB;AAC1B,kBAAgB;AAEhB;AACA,UAAQ,KAAe,SAAS,OAAQ,SAAS;AAEjD,SAAO;AAAA,OACF;AAAA,QACC;AACF,aAAO,CAAC,GAAG;AAAA;AAAA,IAEb,QAAQ,iBAAiB,OAAO,OAAO,OAAO,GAAG;AAAA;AAAA;AAkB9C,4BAA8B,WAA+C;AAAA,EAClF,IAAI;AAAA,EACJ,aAAc,OAAM,QAAQ,SAAS,QAAS,MAAoB,QAAQ,KAAK;AAAA;AAM1E,kBAAoB;AACzB,SAAQ,IAAI,eAAgB,sBAAsB;AAElD,eAAa,IAAK,YAAY;AAE9B,SAAO,SAAS,OAAO,KAAK,YAAY,OACtC,gBACE,GAAG,SAAS,OAAO,KAAK,UAAW,WAAsC,SAC3E,OACG;AAAA;",
  "names": []
}
