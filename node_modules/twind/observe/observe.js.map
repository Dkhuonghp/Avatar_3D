{
  "version": 3,
  "sources": ["../../src/observe/index.ts"],
  "sourcesContent": ["import type { TW } from '../types'\nimport { tw as defaultTW } from '../index'\n\nexport interface ShimConfiguration {\n  tw?: TW\n}\n\n/** Provides the ability to watch for changes being made to the DOM tree. */\nexport interface TwindObserver {\n  /**\n   * Stops observer from observing any mutations.\n   */\n  disconnect(): TwindObserver\n\n  /**\n   * Observe an additional element.\n   */\n  observe(target: Node): TwindObserver\n}\n\nconst caches = new WeakMap<TW, Map<string, string>>()\n\nconst getCache = (tw: TW): Map<string, string> => {\n  let rulesToClassCache = caches.get(tw)\n\n  if (!rulesToClassCache) {\n    rulesToClassCache = new Map<string, string>()\n    caches.set(tw, rulesToClassCache)\n  }\n\n  return rulesToClassCache\n}\n\nexport const createObserver = ({ tw = defaultTW }: ShimConfiguration = {}): TwindObserver => {\n  const rulesToClassCache = getCache(tw)\n\n  const handleMutation = ({ target, addedNodes }: MinimalMutationRecord): void => {\n    // Not using target.classList.value (not supported in all browsers) or target.class (this is an SVGAnimatedString for svg)\n    const rules = (target as Element).getAttribute?.('class')\n\n    if (rules) {\n      let className = rulesToClassCache.get(rules)\n\n      if (!className) {\n        className = tw(rules)\n\n        // Remember the generated class name\n        rulesToClassCache.set(rules, className)\n\n        // Ensure the cache does not grow unlimited\n        if (rulesToClassCache.size > 10000) {\n          rulesToClassCache.delete(rulesToClassCache.keys().next().value)\n        }\n      }\n\n      if (rules !== className) {\n        // Not using `target.className = ...` as that is read-only for SVGElements\n        // eslint-disable-next-line @typescript-eslint/no-extra-semi\n        ;(target as Element).setAttribute('class', className)\n      }\n    }\n\n    for (let index = addedNodes.length; index--; ) {\n      const node = addedNodes[index]\n\n      handleMutations([\n        {\n          target: node,\n          addedNodes: (node as Element).children || [],\n        },\n      ])\n    }\n  }\n\n  const handleMutations = (mutations: MinimalMutationRecord[]): void =>\n    mutations.forEach(handleMutation)\n\n  const observer = new MutationObserver(handleMutations)\n\n  return {\n    observe(target) {\n      handleMutations([{ target, addedNodes: [target] }])\n\n      observer.observe(target, {\n        attributes: true,\n        attributeFilter: ['class'],\n        subtree: true,\n        childList: true,\n      })\n\n      return this\n    },\n\n    disconnect() {\n      observer.disconnect()\n      return this\n    },\n  }\n}\nexport function observe(\n  this: ShimConfiguration | undefined | void,\n  target: Node,\n  config: ShimConfiguration | undefined | void = this,\n): TwindObserver {\n  return createObserver(config as ShimConfiguration | undefined).observe(target)\n}\n\n/**\n * Simplified MutationRecord which allows use to pass an\n * ArrayLike (compatible with Array and NodeList) `addedNodes` and\n * omit other properties we are not interested in.\n */\ninterface MinimalMutationRecord {\n  readonly addedNodes: ArrayLike<Node>\n  readonly target: Node\n}\n"],
  "mappings": "AACA,wBAmBA,IAAM,EAAS,GAAI,WAEF,IACf,MAAwB,EAAO,IAAI,GAEnC,MAAK,IACH,GAAoB,GAAI,KACxB,EAAO,IAAI,EAAI,IAGV,KAGqB,EAAG,KAAK,GAAiC,MACrE,MAA0B,EAAS,KAEZ,EAAG,SAAQ,iBApCpC,MAsCI,MAAe,KAAmB,eAAnB,qBAAkC,SAEjD,GAAI,GACF,MAAgB,EAAkB,IAAI,GAEtC,AAAK,GACH,GAAY,EAAG,GAGf,EAAkB,IAAI,EAAO,GAG7B,AAAI,EAAkB,KAAO,KAC3B,EAAkB,OAAO,EAAkB,OAAO,OAAO,QAI7D,AAAI,IAAU,GAGV,EAAmB,aAAa,QAAS,GAI/C,UAAiB,EAAW,OAAQ,MAClC,MAAa,EAAW,GAExB,EAAgB,CACd,CACE,OAAQ,EACR,WAAa,EAAiB,UAAY,UAM1B,GACtB,EAAU,QAAQ,KAEH,GAAI,kBAAiB,GAEtC,MAAO,CACL,WACE,SAAgB,CAAC,CAAE,SAAQ,WAAY,CAAC,MAExC,EAAS,QAAQ,EAAQ,CACvB,WAAY,GACZ,gBAAiB,CAAC,SAClB,QAAS,GACT,UAAW,KAGN,MAGT,aACE,SAAS,aACF,QAIN,eAG0C,MAE/C,MAAO,GAAe,GAAyC,QAAQ",
  "names": []
}
