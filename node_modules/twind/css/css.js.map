{
  "version": 3,
  "sources": ["../../src/css/index.ts"],
  "sourcesContent": ["import type { TW, CSSRules, CSSAtKeyframes, InlineDirective, Context } from '../types'\n\nimport { tw as defaultTW, hash } from '../index'\n\nexport interface LazyInjected {\n  valueOf: () => string\n  toString: () => string\n}\n\nexport interface CSSDirective extends LazyInjected {\n  (context: { tw: TW }): CSSRules\n}\n\nconst create = <P, R>(\n  factory: (parameter: P, key: string) => InlineDirective,\n): ((parameter: P) => R) => {\n  type Instance = (parameter: P) => R\n\n  // Cache css directive by their JSON stringified value\n  const instances = new WeakMap<TW, Instance>()\n\n  const build = (tw: TW): Instance => {\n    // Allows to invoke toString() on a directive:\n    // document.body.className = css({ color: 'white' })\n    function toString(this: InlineDirective): string {\n      return tw(this)\n    }\n\n    const cache = new Map<string, R>()\n\n    const evaluateFunctions = (key: string, value: unknown): unknown =>\n      typeof value === 'function' ? tw(value as InlineDirective) : value\n\n    return (rules: P): R => {\n      const key = JSON.stringify(rules, evaluateFunctions)\n\n      let directive = cache.get(key)\n\n      if (!directive) {\n        directive = Object.defineProperties(factory(rules, key), {\n          valueOf: {\n            value: toString,\n          },\n          toString: {\n            value: toString,\n          },\n          // Allow twind to generate a unique id for this inline directive\n          // twind uses JSON.stringify which returns undefined for functions like this directive\n          // providing a toJSON function allows to include this directive in the id generation\n          toJSON: {\n            value: () => rules,\n          },\n        }) as R\n\n        cache.set(key, directive)\n\n        // Ensure the cache does not grow unlimited\n        if (cache.size > 10000) {\n          cache.delete(cache.keys().next().value)\n        }\n      }\n\n      return directive\n    }\n  }\n\n  return function (this: TW | null | undefined | void, rules: P): R {\n    const tw = this || defaultTW\n\n    let instance = instances.get(tw)\n\n    if (!instance) {\n      instance = build(tw)\n      instances.set(tw, instance)\n    }\n\n    return instance(rules)\n  }\n}\n\nexport const css = create<CSSRules, CSSDirective>((rules) => {\n  const plugin: InlineDirective = () => rules\n\n  return ({ tw }) => tw(plugin)\n})\n\nexport interface CSSKeyframes extends LazyInjected {\n  (context: Context): string\n}\n\n/**\n *\n * ```js\n * const bounce = keyframes({\n *   'from, 20%, 53%, 80%, to': {\n *     transform: 'translate3d(0,0,0)',\n *   },\n *   '40%, 43%': {\n *     transform: 'translate3d(0, -30px, 0)',\n *   },\n *   '70%': {\n *     transform: 'translate3d(0, -15px, 0)',\n *   },\n *   '90%': {\n *     transform: 'translate3d(0, -4px, 0)',\n *   }\n * })\n *\n * css({\n *   animation: `${bounce} 1s ease infinite`,\n * })\n * ```\n * @param waypoints\n */\nexport const keyframes = create<CSSAtKeyframes, CSSKeyframes>((waypoints, key) => {\n  const id = hash(key)\n\n  // tw caches inline plugins by the identity\n  const plugin: InlineDirective = () => ({\n    [`@keyframes ${id}`]: waypoints,\n  })\n\n  return ({ tw }) => {\n    // Inject the keyframes\n    tw(plugin)\n    // but return the keyframe id\n    return id\n  }\n})\n\n/**\n *\n * ```js\n * const bounce = animation('1s ease infinite', {\n *   'from, 20%, 53%, 80%, to': {\n *     transform: 'translate3d(0,0,0)',\n *   },\n *   '40%, 43%': {\n *     transform: 'translate3d(0, -30px, 0)',\n *   },\n *   '70%': {\n *     transform: 'translate3d(0, -15px, 0)',\n *   },\n *   '90%': {\n *     transform: 'translate3d(0, -4px, 0)',\n *   }\n * })\n * ```\n */\nexport function animation(\n  this: TW | null | undefined | void,\n  value: string | CSSRules | ((context: Context) => string),\n  waypoints: CSSAtKeyframes | CSSKeyframes,\n): CSSDirective {\n  return css.call(this, {\n    ...(typeof value === 'object' ? value : { animation: value }),\n    animationName: typeof waypoints === 'function' ? waypoints : keyframes.call(this, waypoints),\n  })\n}\n"],
  "mappings": "AAEA,kCAWA,IAAM,EAAS,IAMb,MAAkB,GAAI,WAER,IAGZ,aACE,MAAO,GAAG,MAGZ,MAAc,GAAI,OAEQ,OACxB,MAAO,IAAU,WAAa,EAAG,GAA4B,EAE/D,MAAO,KACL,MAAY,KAAK,UAAU,EAAO,KAElB,EAAM,IAAI,GAE1B,MAAK,IACH,GAAY,OAAO,iBAAiB,EAAQ,EAAO,GAAM,CACvD,QAAS,CACP,MAAO,GAET,SAAU,CACR,MAAO,GAKT,OAAQ,CACN,MAAO,IAAM,KAIjB,EAAM,IAAI,EAAK,GAGf,AAAI,EAAM,KAAO,KACf,EAAM,OAAO,EAAM,OAAO,OAAO,QAI9B,IAIX,MAAO,aACL,MAAW,MAAQ,IAEJ,EAAU,IAAI,GAE7B,MAAK,IACH,GAAW,EAAM,GACjB,EAAU,IAAI,EAAI,IAGb,EAAS,OAID,EAA+B,IAChD,MAAgC,IAAM,EAEtC,MAAO,EAAG,QAAS,EAAG,OA+BC,EAAqC,QAC5D,MAAW,EAAK,KAGgB,IAAO,GACpC,cAAc,KAAO,IAGxB,MAAO,EAAG,QAER,GAAG,GAEI,KAuBJ,gBAKL,MAAO,GAAI,KAAK,KAAM,IAChB,MAAO,IAAU,SAAW,EAAQ,CAAE,UAAW,GACrD,cAAe,MAAO,IAAc,WAAa,EAAY,EAAU,KAAK,KAAM",
  "names": []
}
