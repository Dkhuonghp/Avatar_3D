{
  "version": 3,
  "sources": ["../../src/css/index.ts", "../../src/css/index.ts"],
  "sourcesContent": ["import type { TW, CSSRules, CSSAtKeyframes, InlineDirective, Context } from '../types'\n\nimport { tw as defaultTW, hash } from '../index'\n\nexport interface LazyInjected {\n  valueOf: () => string\n  toString: () => string\n}\n\nexport interface CSSDirective extends LazyInjected {\n  (context: { tw: TW }): CSSRules\n}\n\nconst create = <P, R>(\n  factory: (parameter: P, key: string) => InlineDirective,\n): ((parameter: P) => R) => {\n  type Instance = (parameter: P) => R\n\n  // Cache css directive by their JSON stringified value\n  const instances = new WeakMap<TW, Instance>()\n\n  const build = (tw: TW): Instance => {\n    // Allows to invoke toString() on a directive:\n    // document.body.className = css({ color: 'white' })\n    function toString(this: InlineDirective): string {\n      return tw(this)\n    }\n\n    const cache = new Map<string, R>()\n\n    const evaluateFunctions = (key: string, value: unknown): unknown =>\n      typeof value === 'function' ? tw(value as InlineDirective) : value\n\n    return (rules: P): R => {\n      const key = JSON.stringify(rules, evaluateFunctions)\n\n      let directive = cache.get(key)\n\n      if (!directive) {\n        directive = Object.defineProperties(factory(rules, key), {\n          valueOf: {\n            value: toString,\n          },\n          toString: {\n            value: toString,\n          },\n          // Allow twind to generate a unique id for this inline directive\n          // twind uses JSON.stringify which returns undefined for functions like this directive\n          // providing a toJSON function allows to include this directive in the id generation\n          toJSON: {\n            value: () => rules,\n          },\n        }) as R\n\n        cache.set(key, directive)\n\n        // Ensure the cache does not grow unlimited\n        if (cache.size > 10000) {\n          cache.delete(cache.keys().next().value)\n        }\n      }\n\n      return directive\n    }\n  }\n\n  return function (this: TW | null | undefined | void, rules: P): R {\n    const tw = this || defaultTW\n\n    let instance = instances.get(tw)\n\n    if (!instance) {\n      instance = build(tw)\n      instances.set(tw, instance)\n    }\n\n    return instance(rules)\n  }\n}\n\nexport const css = create<CSSRules, CSSDirective>((rules) => {\n  const plugin: InlineDirective = () => rules\n\n  return ({ tw }) => tw(plugin)\n})\n\nexport interface CSSKeyframes extends LazyInjected {\n  (context: Context): string\n}\n\n/**\n *\n * ```js\n * const bounce = keyframes({\n *   'from, 20%, 53%, 80%, to': {\n *     transform: 'translate3d(0,0,0)',\n *   },\n *   '40%, 43%': {\n *     transform: 'translate3d(0, -30px, 0)',\n *   },\n *   '70%': {\n *     transform: 'translate3d(0, -15px, 0)',\n *   },\n *   '90%': {\n *     transform: 'translate3d(0, -4px, 0)',\n *   }\n * })\n *\n * css({\n *   animation: `${bounce} 1s ease infinite`,\n * })\n * ```\n * @param waypoints\n */\nexport const keyframes = create<CSSAtKeyframes, CSSKeyframes>((waypoints, key) => {\n  const id = hash(key)\n\n  // tw caches inline plugins by the identity\n  const plugin: InlineDirective = () => ({\n    [`@keyframes ${id}`]: waypoints,\n  })\n\n  return ({ tw }) => {\n    // Inject the keyframes\n    tw(plugin)\n    // but return the keyframe id\n    return id\n  }\n})\n\n/**\n *\n * ```js\n * const bounce = animation('1s ease infinite', {\n *   'from, 20%, 53%, 80%, to': {\n *     transform: 'translate3d(0,0,0)',\n *   },\n *   '40%, 43%': {\n *     transform: 'translate3d(0, -30px, 0)',\n *   },\n *   '70%': {\n *     transform: 'translate3d(0, -15px, 0)',\n *   },\n *   '90%': {\n *     transform: 'translate3d(0, -4px, 0)',\n *   }\n * })\n * ```\n */\nexport function animation(\n  this: TW | null | undefined | void,\n  value: string | CSSRules | ((context: Context) => string),\n  waypoints: CSSAtKeyframes | CSSKeyframes,\n): CSSDirective {\n  return css.call(this, {\n    ...(typeof value === 'object' ? value : { animation: value }),\n    animationName: typeof waypoints === 'function' ? waypoints : keyframes.call(this, waypoints),\n  })\n}\n", "import type { TW, CSSRules, CSSAtKeyframes, InlineDirective, Context } from '../types'\n\nimport { tw as defaultTW, hash } from '../index'\n\nexport interface LazyInjected {\n  valueOf: () => string\n  toString: () => string\n}\n\nexport interface CSSDirective extends LazyInjected {\n  (context: { tw: TW }): CSSRules\n}\n\nconst create = <P, R>(\n  factory: (parameter: P, key: string) => InlineDirective,\n): ((parameter: P) => R) => {\n  type Instance = (parameter: P) => R\n\n  // Cache css directive by their JSON stringified value\n  const instances = new WeakMap<TW, Instance>()\n\n  const build = (tw: TW): Instance => {\n    // Allows to invoke toString() on a directive:\n    // document.body.className = css({ color: 'white' })\n    function toString(this: InlineDirective): string {\n      return tw(this)\n    }\n\n    const cache = new Map<string, R>()\n\n    const evaluateFunctions = (key: string, value: unknown): unknown =>\n      typeof value === 'function' ? tw(value as InlineDirective) : value\n\n    return (rules: P): R => {\n      const key = JSON.stringify(rules, evaluateFunctions)\n\n      let directive = cache.get(key)\n\n      if (!directive) {\n        directive = Object.defineProperties(factory(rules, key), {\n          valueOf: {\n            value: toString,\n          },\n          toString: {\n            value: toString,\n          },\n          // Allow twind to generate a unique id for this inline directive\n          // twind uses JSON.stringify which returns undefined for functions like this directive\n          // providing a toJSON function allows to include this directive in the id generation\n          toJSON: {\n            value: () => rules,\n          },\n        }) as R\n\n        cache.set(key, directive)\n\n        // Ensure the cache does not grow unlimited\n        if (cache.size > 10000) {\n          cache.delete(cache.keys().next().value)\n        }\n      }\n\n      return directive\n    }\n  }\n\n  return function (this: TW | null | undefined | void, rules: P): R {\n    const tw = this || defaultTW\n\n    let instance = instances.get(tw)\n\n    if (!instance) {\n      instance = build(tw)\n      instances.set(tw, instance)\n    }\n\n    return instance(rules)\n  }\n}\n\nexport const css = create<CSSRules, CSSDirective>((rules) => {\n  const plugin: InlineDirective = () => rules\n\n  return ({ tw }) => tw(plugin)\n})\n\nexport interface CSSKeyframes extends LazyInjected {\n  (context: Context): string\n}\n\n/**\n *\n * ```js\n * const bounce = keyframes({\n *   'from, 20%, 53%, 80%, to': {\n *     transform: 'translate3d(0,0,0)',\n *   },\n *   '40%, 43%': {\n *     transform: 'translate3d(0, -30px, 0)',\n *   },\n *   '70%': {\n *     transform: 'translate3d(0, -15px, 0)',\n *   },\n *   '90%': {\n *     transform: 'translate3d(0, -4px, 0)',\n *   }\n * })\n *\n * css({\n *   animation: `${bounce} 1s ease infinite`,\n * })\n * ```\n * @param waypoints\n */\nexport const keyframes = create<CSSAtKeyframes, CSSKeyframes>((waypoints, key) => {\n  const id = hash(key)\n\n  // tw caches inline plugins by the identity\n  const plugin: InlineDirective = () => ({\n    [`@keyframes ${id}`]: waypoints,\n  })\n\n  return ({ tw }) => {\n    // Inject the keyframes\n    tw(plugin)\n    // but return the keyframe id\n    return id\n  }\n})\n\n/**\n *\n * ```js\n * const bounce = animation('1s ease infinite', {\n *   'from, 20%, 53%, 80%, to': {\n *     transform: 'translate3d(0,0,0)',\n *   },\n *   '40%, 43%': {\n *     transform: 'translate3d(0, -30px, 0)',\n *   },\n *   '70%': {\n *     transform: 'translate3d(0, -15px, 0)',\n *   },\n *   '90%': {\n *     transform: 'translate3d(0, -4px, 0)',\n *   }\n * })\n * ```\n */\nexport function animation(\n  this: TW | null | undefined | void,\n  value: string | CSSRules | ((context: Context) => string),\n  waypoints: CSSAtKeyframes | CSSKeyframes,\n): CSSDirective {\n  return css.call(this, {\n    ...(typeof value === 'object' ? value : { animation: value }),\n    animationName: typeof waypoints === 'function' ? waypoints : keyframes.call(this, waypoints),\n  })\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;ACEA,IAAA,IAAsC;AAWtC,aAAe;AAMb,oBAAkB,IAAI;AAEtB,gBAAc;AAGZ;AACE,aAAO,GAAG;AAAA;AAGZ,kBAAc,IAAI;AAElB,8BAA0B,gBACxB,OAAO,UAAU,aAAa,GAAG,SAA4B;AAE/D,WAAO;AACL,kBAAY,KAAK,UAAU,OAAO;AAElC,sBAAgB,MAAM,IAAI;AAE1B,UAAI,CAAC;AACH,oBAAY,OAAO,iBAAiB,QAAQ,OAAO,MAAM;AAAA,UACvD,SAAS;AAAA,YACP,OAAO;AAAA;AAAA,UAET,UAAU;AAAA,YACR,OAAO;AAAA;AAAA,UAKT,QAAQ;AAAA,YACN,OAAO,MAAM;AAAA;AAAA;AAIjB,cAAM,IAAI,KAAK;AAGf,YAAI,MAAM,OAAO;AACf,gBAAM,OAAO,MAAM,OAAO,OAAO;AAAA;AAAA;AAIrC,aAAO;AAAA;AAAA;AAIX,SAAO;AACL,eAAW,QAAQ;AAEnB,mBAAe,UAAU,IAAI;AAE7B,QAAI,CAAC;AACH,iBAAW,MAAM;AACjB,gBAAU,IAAI,IAAI;AAAA;AAGpB,WAAO,SAAS;AAAA;AAAA;AAIb,UAAY,OAA+B;AAChD,iBAAgC,MAAM;AAEtC,SAAO,EAAG,QAAS,GAAG;AAAA;AA+BjB,gBAAkB,OAAqC;AAC5D,aAAW,OAAK;AAGhB,iBAAgC,MAAO;AAAA,KACpC,cAAc,OAAO;AAAA;AAGxB,SAAO,EAAG;AAER,OAAG;AAEH,WAAO;AAAA;AAAA;AAuBJ;AAKL,SAAO,IAAI,KAAK,MAAM;AAAA,OAChB,OAAO,UAAU,WAAW,QAAQ,CAAE,WAAW;AAAA,IACrD,eAAe,OAAO,cAAc,aAAa,YAAY,UAAU,KAAK,MAAM;AAAA;AAAA;",
  "names": []
}
