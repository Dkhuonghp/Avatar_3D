import { PropertiesFallback, PropertiesHyphenFallback, SimplePseudos } from 'csstype';

interface CSSCustomProperties {
    '--tw-rotate'?: string;
    '--tw-gradient-stops'?: string;
}
interface CSSProperties extends PropertiesFallback<string, string>, PropertiesHyphenFallback<string, string>, CSSCustomProperties {
}
declare type CSSAtKeyframes = Record<string, CSSProperties>;

interface ThemeResolver {
    <Section extends keyof Theme>(section: Section): Record<string, ThemeSectionType<Theme[Section]>>;
    <Section extends keyof Theme>(keypath: `${Section}.${string}`): ThemeSectionType<Theme[Section]> | undefined;
    <Section extends keyof Theme>(keypath: `${Section}.${string}`, defaultValue: NonNullable<ThemeSectionType<Theme[Section]>>): NonNullable<ThemeSectionType<Theme[Section]>>;
    <Section extends keyof Theme>(section: Section, key: string | string[]): ThemeSectionType<Theme[Section]> | undefined;
    <Section extends keyof Theme>(section: Section, key: string | string[], defaultValue: NonNullable<ThemeSectionType<Theme[Section]>>): NonNullable<ThemeSectionType<Theme[Section]>>;
}
declare type Unwrap<T> = T extends string[] ? string : T extends Record<string, infer R> ? R : T;
declare type ThemeSectionType<T> = T extends ThemeSection<infer R> ? Unwrap<R> : Exclude<T, ThemeSectionResolver<T>>;
interface ThemeSectionResolverContext {
    /**
     * No-op function as negated values are automatically infered and do _not_ not to be in the theme.
     */
    readonly negative: (records: Record<string, string | undefined>) => Record<string, string | undefined>;
    readonly breakpoints: (records: Record<string, string | undefined>) => Record<string, string | undefined>;
}
declare type ThemeSectionRecord<T = string> = Record<string, T | undefined>;
declare type ThemeSectionResolver<T = string> = (theme: ThemeResolver, context: ThemeSectionResolverContext) => ThemeSectionRecord<T>;
declare type ThemeSection<T = string> = ThemeSectionRecord<T> | ThemeSectionResolver<T>;
interface ThemeContainer {
    screens?: Record<string, string | undefined>;
    center?: boolean;
    padding?: string | Record<string, string | undefined>;
}
interface ThemeColorObject extends Record<string, ThemeColor> {
}
declare type ThemeColor = string | ThemeColorObject;
declare type ThemeFontSize = string | [size: string, lineHeight: string] | [size: string, options: {
    lineHeight?: string;
    letterSpacing?: string;
}];
declare type ThemeOutline = [outline: string, offset: string];
interface Theme {
    colors: ThemeSection<ThemeColor>;
    spacing: ThemeSection;
    durations: ThemeSection<string | string[]>;
    screens: ThemeSection;
    animation: ThemeSection<string | string[]>;
    backgroundColor: ThemeSection<ThemeColor>;
    backgroundImage: ThemeSection<string | string[]>;
    backgroundOpacity: ThemeSection;
    borderColor: ThemeSection<ThemeColor>;
    borderOpacity: ThemeSection;
    borderRadius: ThemeSection;
    borderWidth: ThemeSection;
    boxShadow: ThemeSection<string | string[]>;
    container: ThemeContainer | ThemeSectionResolver<ThemeContainer>;
    divideColor: ThemeSection<ThemeColor>;
    divideOpacity: ThemeSection;
    divideWidth: ThemeSection;
    fill: ThemeSection<ThemeColor>;
    flex: ThemeSection;
    fontFamily: ThemeSection<string | string[]>;
    fontSize: ThemeSection<ThemeFontSize>;
    fontWeight: ThemeSection;
    gap: ThemeSection;
    gradientColorStops: ThemeSection<ThemeColor>;
    height: ThemeSection;
    inset: ThemeSection;
    keyframes: ThemeSection<CSSAtKeyframes>;
    letterSpacing: ThemeSection;
    lineHeight: ThemeSection;
    margin: ThemeSection;
    maxHeight: ThemeSection;
    maxWidth: ThemeSection;
    minHeight: ThemeSection;
    minWidth: ThemeSection;
    opacity: ThemeSection;
    order: ThemeSection;
    outline: ThemeSection<ThemeOutline>;
    padding: ThemeSection;
    placeholderColor: ThemeSection<ThemeColor>;
    placeholderOpacity: ThemeSection;
    ringColor: ThemeSection<ThemeColor>;
    ringOffsetColor: ThemeSection<ThemeColor>;
    ringOffsetWidth: ThemeSection;
    ringOpacity: ThemeSection;
    ringWidth: ThemeSection;
    rotate: ThemeSection;
    scale: ThemeSection;
    skew: ThemeSection;
    space: ThemeSection;
    stroke: ThemeSection<ThemeColor>;
    strokeWidth: ThemeSection;
    textColor: ThemeSection<ThemeColor>;
    textOpacity: ThemeSection;
    transitionDelay: ThemeSection<string | string[]>;
    transitionDuration: ThemeSection<string | string[]>;
    transitionProperty: ThemeSection<string | string[]>;
    transitionTimingFunction: ThemeSection<string | string[]>;
    translate: ThemeSection;
    width: ThemeSection;
    zIndex: ThemeSection;
}

declare type Falsy = '' | 0 | -0 | false | null | undefined | void;

interface TW {
    (strings: TemplateStringsArray, ...interpolations: Token[]): string;
    (...tokens: Token[]): string;
}
interface Context {
    /** Allow composition */
    readonly tw: TW;
    /** Access to theme values */
    readonly theme: ThemeResolver;
    /** Create unique identifier (group, custom properties) */
    readonly tag: (key: string) => string;
}
interface Instance {
    readonly tw: TW;
    readonly setup: (options?: Configuration) => void;
    readonly theme: ThemeResolver;
}
interface Preflight {
    (preflight: CSSRules, context: Context): CSSRules | undefined | void;
}
interface ThemeConfiguration extends Partial<Theme> {
    extend?: Partial<Theme>;
}
interface SheetConfig<T = unknown> {
    /**
     * Sets a cryptographic nonce (number used once) on the enclosing `<style>` tag when generating a page on demand.
     *
     * Useful for enforcing a [Content Security Policy (CSP)](https://developer.mozilla.org/docs/Web/HTTP/CSP).
     */
    nonce?: string;
    /** Target to insert rules into. */
    target?: T;
}
interface Sheet<T = unknown> {
    readonly target: T;
    insert: (rule: string, index: number) => void;
    init?: SheetInit;
}
declare type SheetInitCallback<T = unknown> = (value?: T | undefined) => T;
interface SheetInit {
    /**
     * Register a function that should be called to use a snapshot state or create a new state.
     */
    <T>(callback: SheetInitCallback<T>): T;
}
declare type Prefixer = (property: string, value: string, important?: boolean) => string;
declare type Hasher = (value: string) => string;
declare type DarkMode = 'media' | 'class' | false;
interface Configuration {
    /**
     * Determines the dark mode strategy (default: `"media"`).
     */
    darkMode?: DarkMode;
    theme?: ThemeConfiguration;
    plugins?: Plugins;
    /**
     * ```js
     * {
     *   ':new-variant': '& .selector',
     * }
     * ```
     */
    variants?: Record<string, string>;
    /**
     * Sets a cryptographic nonce (number used once) on the enclosing `<style>` tag when generating a page on demand.
     *
     * Useful for enforcing a [Content Security Policy (CSP)](https://developer.mozilla.org/docs/Web/HTTP/CSP).
     */
    nonce?: string;
    /** Style insertion methodology to be used. */
    sheet?: Sheet;
    /** Called right before the first rule is injected. */
    preflight?: Preflight | boolean | CSSRules;
    /** Auto-prefixer method for CSS propertyâ€“value pairs. */
    prefix?: Prefixer | boolean;
    hash?: Hasher | boolean;
    mode?: Mode | 'strict' | 'warn' | 'silent';
}
declare type ReportInfo = {
    id: 'LATE_SETUP_CALL';
} | {
    id: 'UNKNOWN_DIRECTIVE';
    rule: string;
} | {
    id: 'UNKNOWN_THEME_VALUE';
    key: string | undefined;
} | {
    id: 'INJECT_CSS_ERROR';
    error: Error;
    css: string;
};
interface Mode {
    /** Called for unknown theme values */
    unknown: <Section extends keyof Theme>(section: Section, key: string[] | undefined, optional: boolean, context: Context) => ThemeSectionType<Theme[Section]> | undefined | void;
    /**
     * Notify error (missing plugin, duplicate directives? )
     *
     * Why id?
     * - can generate an url with more info
     * - reduce bundle size by omitting large error messages
     */
    report(info: ReportInfo, context: Context): void;
}
declare type Plugin = string | CSSRules | DirectiveHandler;
declare type Plugins = Record<string, Plugin | undefined>;
interface DirectiveHandler {
    /**
     * Creates CSSRules based on `parameters`
     */
    (parameters: string[], context: Context, id: string): CSSRules | string | Falsy;
}
interface Rule {
    /**
     * The variants: `[":sm", ":dark", ":hover"]`
     */
    v: string[];
    /**
     * The directive: `"text-sm"`, `"rotate-45"`
     */
    d: string | InlineDirective;
    /** Is this rule negated: `"-rotate-45"` =\> `true` */
    n: boolean | undefined;
    /** Is this rule marked as important: `"stroke-4!"` =\> `true` */
    i: boolean | undefined;
    /**
     * The id is the tailwind rule including variants, negate and directive
     *
     * Initialy this is set to an empty string.
     *
     * This is used to cache the id of static rules (from template literals).
     */
    $: string;
}
interface InlineDirective {
    (context: Context): CSSRules | string | Falsy;
}
interface TokenGrouping extends Record<string, Token> {
}
declare type TypescriptCompat = boolean | number;
declare type Token = string | TokenGrouping | InlineDirective | Token[] | Falsy | TypescriptCompat;
/**
 * Pseudo class
 * watch out for ':root' - that could use '*' instead
 */
declare type CSSSimplePseudos = {
    [K in SimplePseudos as `&${string & K}`]?: CSSRules;
};
interface CSSPseudos extends CSSSimplePseudos {
    '&:nth-child(2n)'?: CSSRules;
    '&:nth-child(odd)'?: CSSRules;
}
declare type CSSAtMedia = Record<string, CSSRules>;
declare type CSSAtSupports = Record<string, CSSRules>;
/**
 * See: https://drafts.csswg.org/css-nesting/#nest-selector
 *
 * ```
 * "& > * + *": {
 *   marginLeft: 16
 * },
 *
 * // In a comma-separated list, each individual selector shall start with "&"
 * "&:focus, &:active": {
 *   outline: "solid"
 * },
 *
 * // Self-references are also supported
 * "& + &": {
 *   color: "green"
 * }
 * ```
 */
interface CSSRules {
    /** Global defaults */
    [key: string]: CSSProperties | CSSAtMedia | CSSAtSupports | CSSAtKeyframes | CSSRules | string | string[] | Falsy | ((context: Context) => CSSProperties | CSSAtMedia | CSSAtSupports | CSSAtKeyframes | CSSRules | string | string[] | Falsy);
}

declare const create: (config?: Configuration | undefined) => Instance;

/**
 * Creates an sheet which inserts style rules through the CSS Object Model.
 */
declare const cssomSheet: ({ nonce, target, }?: SheetConfig<CSSStyleSheet>) => Sheet<CSSStyleSheet>;
/**
 * An sheet placeholder which performs no operations. Useful for avoiding errors in a non-browser environment.
 */
declare const voidSheet: () => Sheet<null>;

declare const mode: (report: (message: string) => void) => Mode;
declare const warn: Mode;
declare const strict: Mode;
declare const silent: Mode;

declare const noprefix: Prefixer;
declare const autoprefix: Prefixer;

declare const cyrb32: Hasher;

declare const tw: TW;
declare const setup: (options?: Configuration | undefined) => void;
declare const theme: ThemeResolver;

export { CSSAtKeyframes, CSSAtMedia, CSSAtSupports, CSSCustomProperties, CSSProperties, CSSPseudos, CSSRules, CSSSimplePseudos, Configuration, Context, DarkMode, DirectiveHandler, Falsy, Hasher, InlineDirective, Instance, Mode, Plugin, Plugins, Prefixer, Preflight, ReportInfo, Rule, Sheet, SheetConfig, SheetInit, SheetInitCallback, TW, Theme, ThemeColor, ThemeColorObject, ThemeConfiguration, ThemeContainer, ThemeFontSize, ThemeOutline, ThemeResolver, ThemeSection, ThemeSectionRecord, ThemeSectionResolver, ThemeSectionResolverContext, ThemeSectionType, Token, TokenGrouping, TypescriptCompat, Unwrap, autoprefix, create, cssomSheet, cyrb32 as hash, mode, noprefix, setup, silent, strict, theme, tw, voidSheet, warn };
//# sourceMappingURL=twind.d.ts.map
