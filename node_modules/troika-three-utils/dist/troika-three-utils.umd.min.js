'use strict';(function(g,e){"object"===typeof exports&&"undefined"!==typeof module?e(exports,require("three")):"function"===typeof define&&define.amd?define(["exports","three"],e):(g="undefined"!==typeof globalThis?globalThis:g||self,e(g.troika_three_utils={},g.THREE))})(this,function(g,e){function r(a){return a.replace(/^[ \t]*#include +<([\w\d./]+)>/gm,function(a,c){return(c=e.ShaderChunk[c])?r(c):a})}function m(a,b){var c=B(b),d=t.get(a);d||t.set(a,d=Object.create(null));if(d[c])return new d[c];
var f="_onBeforeCompile"+c,E=function(d){a.onBeforeCompile.call(this,d);var p=c+"|||"+d.vertexShader+"|||"+d.fragmentShader,e=u[p];e||(e=C(d,b,c),e=u[p]=e);d.vertexShader=e.vertexShader;d.fragmentShader=e.fragmentShader;k(d.uniforms,this.uniforms);b.timeUniform&&(d.uniforms[b.timeUniform]={get value(){return Date.now()-D}});if(this[f])this[f](d)},g=function(){return h(b.chained?a:a.clone())},h=function(d){var f=Object.create(d,n);Object.defineProperty(f,"baseMaterial",{value:a});Object.defineProperty(f,
"id",{value:G++});f.uuid=e.MathUtils.generateUUID();f.uniforms=k({},d.uniforms,b.uniforms);f.defines=k({},d.defines,b.defines);f.defines["TROIKA_DERIVED_MATERIAL_"+c]="";f.extensions=k({},d.extensions,b.extensions);f._listeners=void 0;return f},n={constructor:{value:g},isDerivedMaterial:{value:!0},customProgramCacheKey:{value:function(){return c}},onBeforeCompile:{get:function(){return E},set:function(a){this[f]=a}},copy:{writable:!0,configurable:!0,value:function(b){a.copy.call(this,b);a.isShaderMaterial||
a.isDerivedMaterial||(k(this.extensions,b.extensions),k(this.defines,b.defines),k(this.uniforms,e.UniformsUtils.clone(b.uniforms)));return this}},clone:{writable:!0,configurable:!0,value:function(){var b=new a.constructor;return h(b).copy(this)}},getDepthMaterial:{writable:!0,configurable:!0,value:function(){var c=this._depthMaterial;c||(c=this._depthMaterial=m(a.isDerivedMaterial?a.getDepthMaterial():new e.MeshDepthMaterial({depthPacking:e.RGBADepthPacking}),b),c.defines.IS_DEPTH_MATERIAL="",c.uniforms=
this.uniforms);return c}},getDistanceMaterial:{writable:!0,configurable:!0,value:function(){var c=this._distanceMaterial;c||(c=this._distanceMaterial=m(a.isDerivedMaterial?a.getDistanceMaterial():new e.MeshDistanceMaterial,b),c.defines.IS_DISTANCE_MATERIAL="",c.uniforms=this.uniforms);return c}},dispose:{writable:!0,configurable:!0,value:function(){var b=this._depthMaterial,c=this._distanceMaterial;b&&b.dispose();c&&c.dispose();a.dispose.call(this)}}};d[c]=g;return new g}function C(a,b,c){var d=a.vertexShader,
f=a.fragmentShader;a=b.vertexDefs;var e=b.vertexMainIntro,g=b.vertexMainOutro,h=b.vertexTransform,n=b.fragmentDefs,p=b.fragmentMainIntro,k=b.fragmentMainOutro,q=b.fragmentColorTransform,l=b.customRewriter;b=b.timeUniform;a=a||"";e=e||"";g=g||"";n=n||"";p=p||"";k=k||"";if(h||l)d=r(d);if(q||l)f=f.replace(/^[ \t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm,"\n//!BEGIN_POST_CHUNK $1\n$&\n//!END_POST_CHUNK\n"),f=r(f);l&&(f=l({vertexShader:d,fragmentShader:f}),d=
f.vertexShader,f=f.fragmentShader);if(q){var m=[];f=f.replace(/^\/\/!BEGIN_POST_CHUNK[^]+?^\/\/!END_POST_CHUNK/gm,function(a){m.push(a);return""});k=q+"\n"+m.join("\n")+"\n"+k}b&&(q="\nuniform float "+b+";\n",a=q+a,n=q+n);h&&(a=a+"\nvec3 troika_position_"+c+";\nvec3 troika_normal_"+c+";\nvec2 troika_uv_"+c+";\nvoid troikaVertexTransform"+c+"(inout vec3 position, inout vec3 normal, inout vec2 uv) {\n  "+h+"\n}\n",e="\ntroika_position_"+c+" = vec3(position);\ntroika_normal_"+c+" = vec3(normal);\ntroika_uv_"+
c+" = vec2(uv);\ntroikaVertexTransform"+c+"(troika_position_"+c+", troika_normal_"+c+", troika_uv_"+c+");\n"+e+"\n",d=d.replace(/\b(position|normal|uv)\b/g,function(a,b,d,f){return/\battribute\s+vec[23]\s+$/.test(f.substr(0,d))?b:"troika_"+b+"_"+c}));d=v(d,c,a,e,g);f=v(f,c,n,p,k);return{vertexShader:d,fragmentShader:f}}function v(a,b,c,d,f){if(d||f||c)a=a.replace(w,"\n"+c+"\nvoid troikaOrigMain"+b+"() {"),a+="\nvoid main() {\n  "+d+"\n  troikaOrigMain"+b+"();\n  "+f+"\n}";return a}function H(a,b){return"uniforms"===
a?void 0:"function"===typeof b?b.toString():b}function B(a){a=JSON.stringify(a,H);var b=x.get(a);null==b&&x.set(a,b=++I);return b}function y(a,b,c){a*=255;var d=a%1*255,f=d%1*255;var e=Math.round(f%1*255)&255;b[c]=a&255;b[c+1]=d&255;b[c+2]=f&255;b[c+3]=e;return b}var w=/\bvoid\s+main\s*\(\s*\)\s*{/g,k=Object.assign||function(){for(var a=arguments,b=arguments[0],c=1,d=arguments.length;c<d;c++){var f=a[c];if(f)for(var e in f)f.hasOwnProperty(e)&&(b[e]=f[e])}return b},D=Date.now(),t=new WeakMap,u=new Map,
G=1E10,I=0,x=new Map,J={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"phong",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"},h=function(a){this.name=a;this.textureUniform="dataTex_"+a;this.textureSizeUniform=
"dataTexSize_"+a;this.multiplierUniform="dataMultiplier_"+a;this.dataSizeUniform="dataSize_"+a;this.readFunction="readData_"+a;this._raw=new Float32Array(0);this._texture=new e.DataTexture(new Uint8Array(0),0,1);this._length=0;this._multiplier=1},l={length:{configurable:!0}};l.length.set=function(a){if(a!==this._length){var b=Math.pow(2,Math.ceil(Math.log2(a))),c=this._raw;b<c.length?this._raw=c.subarray(0,b):b>c.length&&(this._raw=new Float32Array(b),this._raw.set(c));this._length=a}};l.length.get=
function(){return this._length};h.prototype.push=function(a){return this.set(this.length++,a)};h.prototype.setArray=function(a){this.length=a.length;this._raw.set(a);this._needsRepack=!0};h.prototype.get=function(a){return this._raw[a]};h.prototype.set=function(a,b){a+1>this._length&&(this.length=a+1);b!==this._raw[a]&&(this._raw[a]=b,y(b/this._multiplier,this._texture.image.data,4*a),this._needsMultCheck=!0)};h.prototype.clone=function(){var a=new h(this.name);a.setArray(this._raw);return a};h.prototype.getShaderUniforms=
function(){var a,b=this;return a={},a[this.textureUniform]={get value(){b._sync();return b._texture}},a[this.textureSizeUniform]={get value(){b._sync();return b._texture.image.width}},a[this.dataSizeUniform]={get value(){b._sync();return b.length}},a[this.multiplierUniform]={get value(){b._sync();return b._multiplier}},a};h.prototype.getShaderHeaderCode=function(){var a=this.textureUniform,b=this.textureSizeUniform,c=this.multiplierUniform;return"\nuniform sampler2D "+a+";\nuniform float "+b+";\nuniform float "+
this.dataSizeUniform+";\nuniform float "+c+";\n\nfloat "+this.readFunction+"(float index) {\n  vec2 texUV = vec2((index + 0.5) / "+b+", 0.5);\n  vec4 pixel = texture2D("+a+", texUV);\n  return dot(pixel, 1.0 / vec4(1.0, 255.0, 65025.0, 16581375.0)) * "+c+";\n}\n"};h.prototype._sync=function(){var a=this._texture,b=this._raw,c=this._needsRepack;b.length!==a.image.width&&(a.image={data:new Uint8Array(4*b.length),width:b.length,height:1},c=!0);if(c||this._needsMultCheck){var d=this._raw.reduce(function(a,
b){return Math.max(a,b)},0);d=Math.pow(2,Math.ceil(Math.log2(d)));d!==this._multiplier&&(this._multiplier=d,c=!0);a.needsUpdate=!0;this._needsMultCheck=!1}if(c){c=0;d=b.length;for(var f=this._multiplier;c<d;c++)y(b[c]/f,a.image.data,4*c);this._needsRepack=!1}};Object.defineProperties(h.prototype,l);var z=null,A=new e.MeshStandardMaterial({color:16777215,side:e.DoubleSide});l=function(a){function b(){a.call(this,b.getGeometry(),A);this.pointA=new e.Vector3;this.controlA=new e.Vector3;this.controlB=
new e.Vector3;this.pointB=new e.Vector3;this.radius=.01;this.dashArray=new e.Vector2;this.dashOffset=0;this.frustumCulled=!1}a&&(b.__proto__=a);b.prototype=Object.create(a&&a.prototype);b.prototype.constructor=b;var c={material:{configurable:!0},customDepthMaterial:{configurable:!0},customDistanceMaterial:{configurable:!0}};b.getGeometry=function(){return z||(z=(new e.CylinderBufferGeometry(1,1,1,6,64)).translate(0,.5,0))};c.material.get=function(){var a=this._derivedMaterial,b=this._baseMaterial||
this._defaultMaterial||(this._defaultMaterial=A.clone());a&&a.baseMaterial===b||(a=this._derivedMaterial=m(b,{chained:!0,uniforms:{pointA:{value:new e.Vector3},controlA:{value:new e.Vector3},controlB:{value:new e.Vector3},pointB:{value:new e.Vector3},radius:{value:.01},dashing:{value:new e.Vector3}},vertexDefs:"\nuniform vec3 pointA;\nuniform vec3 controlA;\nuniform vec3 controlB;\nuniform vec3 pointB;\nuniform float radius;\nvarying float bezierT;\n\nvec3 cubicBezier(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\n  float t2 = 1.0 - t;\n  float b0 = t2 * t2 * t2;\n  float b1 = 3.0 * t * t2 * t2;\n  float b2 = 3.0 * t * t * t2;\n  float b3 = t * t * t;\n  return b0 * p1 + b1 * c1 + b2 * c2 + b3 * p2;\n}\n\nvec3 cubicBezierDerivative(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\n  float t2 = 1.0 - t;\n  return -3.0 * p1 * t2 * t2 +\n    c1 * (3.0 * t2 * t2 - 6.0 * t2 * t) +\n    c2 * (6.0 * t2 * t - 3.0 * t * t) +\n    3.0 * p2 * t * t;\n}\n",
vertexTransform:'\nfloat t = position.y;\nbezierT = t;\nvec3 bezierCenterPos = cubicBezier(pointA, controlA, controlB, pointB, t);\nvec3 bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t));\n\n// Make "sideways" always perpendicular to the camera ray; this ensures that any twists\n// in the cylinder occur where you won\'t see them: \nvec3 viewDirection = normalMatrix * vec3(0.0, 0.0, 1.0);\nif (bezierDir == viewDirection) {\n  bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t == 1.0 ? t - 0.0001 : t + 0.0001));\n}\nvec3 sideways = normalize(cross(bezierDir, viewDirection));\nvec3 upish = normalize(cross(sideways, bezierDir));\n\n// Build a matrix for transforming this disc in the cylinder:\nmat4 discTx;\ndiscTx[0].xyz = sideways * radius;\ndiscTx[1].xyz = bezierDir * radius;\ndiscTx[2].xyz = upish * radius;\ndiscTx[3].xyz = bezierCenterPos;\ndiscTx[3][3] = 1.0;\n\n// Apply transform, ignoring original y\nposition = (discTx * vec4(position.x, 0.0, position.z, 1.0)).xyz;\nnormal = normalize(mat3(discTx) * normal);\n',
fragmentDefs:"\nuniform vec3 dashing;\nvarying float bezierT;\n",fragmentMainIntro:"\nif (dashing.x + dashing.y > 0.0) {\n  float dashFrac = mod(bezierT - dashing.z, dashing.x + dashing.y);\n  if (dashFrac > dashing.x) {\n    discard;\n  }\n}\n"}),b.addEventListener("dispose",function F(){b.removeEventListener("dispose",F);a.dispose()}));return a};c.material.set=function(a){this._baseMaterial=a};c.customDepthMaterial.get=function(){return this.material.getDepthMaterial()};c.customDistanceMaterial.get=
function(){return this.material.getDistanceMaterial()};b.prototype.onBeforeRender=function(a){a=this.material.uniforms;var b=this.controlA,c=this.controlB,d=this.pointB,e=this.radius,g=this.dashArray,h=this.dashOffset;a.pointA.value.copy(this.pointA);a.controlA.value.copy(b);a.controlB.value.copy(c);a.pointB.value.copy(d);a.radius.value=e;a.dashing.value.set(g.x,g.y,h||0)};b.prototype.raycast=function(a,b){};Object.defineProperties(b.prototype,c);return b}(e.Mesh);g.BezierMesh=l;g.ShaderFloatArray=
h;g.createDerivedMaterial=m;g.expandShaderIncludes=r;g.getShaderUniformTypes=function(a){for(var b=/\buniform\s+(int|float|vec[234])\s+([A-Za-z_][\w]*)/g,c=Object.create(null),d;null!==(d=b.exec(a));)c[d[2]]=d[1];return c};g.getShadersForMaterial=function(a){var b=J[a.type];return b?e.ShaderLib[b]:a};g.voidMainRegExp=w;Object.defineProperty(g,"__esModule",{value:!0})})
