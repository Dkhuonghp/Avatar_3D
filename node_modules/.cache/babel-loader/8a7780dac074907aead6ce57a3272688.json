{"ast":null,"code":"import { Matrix4, Ray, Sphere, Vector3 } from 'three';\n\nvar _inverseMatrix = new Matrix4();\n\nvar _ray = new Ray();\n\nvar _sphere = new Sphere();\n\nvar _vA = new Vector3();\n\nfunction meshBounds(raycaster, intersects) {\n  var geometry = this.geometry;\n  var material = this.material;\n  var matrixWorld = this.matrixWorld;\n  if (material === undefined) return; // Checking boundingSphere distance to ray\n\n  if (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n\n  _sphere.copy(geometry.boundingSphere);\n\n  _sphere.applyMatrix4(matrixWorld);\n\n  if (raycaster.ray.intersectsSphere(_sphere) === false) return;\n\n  _inverseMatrix.getInverse(matrixWorld);\n\n  _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix); // Check boundingBox before continuing\n\n\n  if (geometry.boundingBox !== null && _ray.intersectBox(geometry.boundingBox, _vA) === null) return;\n  intersects.push({\n    distance: _vA.distanceTo(raycaster.ray.origin),\n    point: _vA.clone(),\n    object: this\n  });\n}\n\nexport { meshBounds };","map":{"version":3,"names":["Matrix4","Ray","Sphere","Vector3","_inverseMatrix","_ray","_sphere","_vA","meshBounds","raycaster","intersects","geometry","material","matrixWorld","undefined","boundingSphere","computeBoundingSphere","copy","applyMatrix4","ray","intersectsSphere","getInverse","boundingBox","intersectBox","push","distance","distanceTo","origin","point","clone","object"],"sources":["/Users/khuong/Downloads/avatar-homepage-demo-forked/node_modules/@react-three/drei/meshBounds.js"],"sourcesContent":["import { Matrix4, Ray, Sphere, Vector3 } from 'three';\n\nlet _inverseMatrix = new Matrix4();\n\nlet _ray = new Ray();\n\nlet _sphere = new Sphere();\n\nlet _vA = new Vector3();\n\nfunction meshBounds(raycaster, intersects) {\n  let geometry = this.geometry;\n  let material = this.material;\n  let matrixWorld = this.matrixWorld;\n  if (material === undefined) return; // Checking boundingSphere distance to ray\n\n  if (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n\n  _sphere.copy(geometry.boundingSphere);\n\n  _sphere.applyMatrix4(matrixWorld);\n\n  if (raycaster.ray.intersectsSphere(_sphere) === false) return;\n\n  _inverseMatrix.getInverse(matrixWorld);\n\n  _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix); // Check boundingBox before continuing\n\n\n  if (geometry.boundingBox !== null && _ray.intersectBox(geometry.boundingBox, _vA) === null) return;\n  intersects.push({\n    distance: _vA.distanceTo(raycaster.ray.origin),\n    point: _vA.clone(),\n    object: this\n  });\n}\n\nexport { meshBounds };\n"],"mappings":"AAAA,SAASA,OAAT,EAAkBC,GAAlB,EAAuBC,MAAvB,EAA+BC,OAA/B,QAA8C,OAA9C;;AAEA,IAAIC,cAAc,GAAG,IAAIJ,OAAJ,EAArB;;AAEA,IAAIK,IAAI,GAAG,IAAIJ,GAAJ,EAAX;;AAEA,IAAIK,OAAO,GAAG,IAAIJ,MAAJ,EAAd;;AAEA,IAAIK,GAAG,GAAG,IAAIJ,OAAJ,EAAV;;AAEA,SAASK,UAAT,CAAoBC,SAApB,EAA+BC,UAA/B,EAA2C;EACzC,IAAIC,QAAQ,GAAG,KAAKA,QAApB;EACA,IAAIC,QAAQ,GAAG,KAAKA,QAApB;EACA,IAAIC,WAAW,GAAG,KAAKA,WAAvB;EACA,IAAID,QAAQ,KAAKE,SAAjB,EAA4B,OAJa,CAIL;;EAEpC,IAAIH,QAAQ,CAACI,cAAT,KAA4B,IAAhC,EAAsCJ,QAAQ,CAACK,qBAAT;;EAEtCV,OAAO,CAACW,IAAR,CAAaN,QAAQ,CAACI,cAAtB;;EAEAT,OAAO,CAACY,YAAR,CAAqBL,WAArB;;EAEA,IAAIJ,SAAS,CAACU,GAAV,CAAcC,gBAAd,CAA+Bd,OAA/B,MAA4C,KAAhD,EAAuD;;EAEvDF,cAAc,CAACiB,UAAf,CAA0BR,WAA1B;;EAEAR,IAAI,CAACY,IAAL,CAAUR,SAAS,CAACU,GAApB,EAAyBD,YAAzB,CAAsCd,cAAtC,EAhByC,CAgBc;;;EAGvD,IAAIO,QAAQ,CAACW,WAAT,KAAyB,IAAzB,IAAiCjB,IAAI,CAACkB,YAAL,CAAkBZ,QAAQ,CAACW,WAA3B,EAAwCf,GAAxC,MAAiD,IAAtF,EAA4F;EAC5FG,UAAU,CAACc,IAAX,CAAgB;IACdC,QAAQ,EAAElB,GAAG,CAACmB,UAAJ,CAAejB,SAAS,CAACU,GAAV,CAAcQ,MAA7B,CADI;IAEdC,KAAK,EAAErB,GAAG,CAACsB,KAAJ,EAFO;IAGdC,MAAM,EAAE;EAHM,CAAhB;AAKD;;AAED,SAAStB,UAAT"},"metadata":{},"sourceType":"module"}