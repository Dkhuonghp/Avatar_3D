{"ast":null,"code":"import { DataTextureLoader, DataUtils, FloatType, HalfFloatType, LinearEncoding, LinearFilter, NearestFilter, RGBEEncoding, RGBEFormat, RGBFormat, UnsignedByteType } from \"../../../build/three.module.js\"; // https://github.com/mrdoob/three.js/issues/5552\n// http://en.wikipedia.org/wiki/RGBE_image_format\n\nvar RGBELoader = function RGBELoader(manager) {\n  DataTextureLoader.call(this, manager);\n  this.type = UnsignedByteType;\n};\n\nRGBELoader.prototype = Object.assign(Object.create(DataTextureLoader.prototype), {\n  constructor: RGBELoader,\n  // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html\n  parse: function parse(buffer) {\n    var\n    /* return codes for rgbe routines */\n    //RGBE_RETURN_SUCCESS = 0,\n    RGBE_RETURN_FAILURE = -1,\n\n    /* default error routine.  change this to change error handling */\n    rgbe_read_error = 1,\n        rgbe_write_error = 2,\n        rgbe_format_error = 3,\n        rgbe_memory_error = 4,\n        rgbe_error = function rgbe_error(rgbe_error_code, msg) {\n      switch (rgbe_error_code) {\n        case rgbe_read_error:\n          console.error(\"RGBELoader Read Error: \" + (msg || ''));\n          break;\n\n        case rgbe_write_error:\n          console.error(\"RGBELoader Write Error: \" + (msg || ''));\n          break;\n\n        case rgbe_format_error:\n          console.error(\"RGBELoader Bad File Format: \" + (msg || ''));\n          break;\n\n        default:\n        case rgbe_memory_error:\n          console.error(\"RGBELoader: Error: \" + (msg || ''));\n      }\n\n      return RGBE_RETURN_FAILURE;\n    },\n\n    /* offsets to red, green, and blue components in a data (float) pixel */\n    //RGBE_DATA_RED = 0,\n    //RGBE_DATA_GREEN = 1,\n    //RGBE_DATA_BLUE = 2,\n\n    /* number of floats per pixel, use 4 since stored in rgba image format */\n    //RGBE_DATA_SIZE = 4,\n\n    /* flags indicating which fields in an rgbe_header_info are valid */\n    RGBE_VALID_PROGRAMTYPE = 1,\n        RGBE_VALID_FORMAT = 2,\n        RGBE_VALID_DIMENSIONS = 4,\n        NEWLINE = \"\\n\",\n        fgets = function fgets(buffer, lineLimit, consume) {\n      lineLimit = !lineLimit ? 1024 : lineLimit;\n      var p = buffer.pos,\n          i = -1,\n          len = 0,\n          s = '',\n          chunkSize = 128,\n          chunk = String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));\n\n      while (0 > (i = chunk.indexOf(NEWLINE)) && len < lineLimit && p < buffer.byteLength) {\n        s += chunk;\n        len += chunk.length;\n        p += chunkSize;\n        chunk += String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));\n      }\n\n      if (-1 < i) {\n        /*for (i=l-1; i>=0; i--) {\n        \tbyteCode = m.charCodeAt(i);\n        \tif (byteCode > 0x7f && byteCode <= 0x7ff) byteLen++;\n        \telse if (byteCode > 0x7ff && byteCode <= 0xffff) byteLen += 2;\n        \tif (byteCode >= 0xDC00 && byteCode <= 0xDFFF) i--; //trail surrogate\n        }*/\n        if (false !== consume) buffer.pos += len + i + 1;\n        return s + chunk.slice(0, i);\n      }\n\n      return false;\n    },\n\n    /* minimal header reading.  modify if you want to parse more information */\n    RGBE_ReadHeader = function RGBE_ReadHeader(buffer) {\n      var line,\n          match,\n          // regexes to parse header info fields\n      magic_token_re = /^#\\?(\\S+)$/,\n          gamma_re = /^\\s*GAMMA\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n          exposure_re = /^\\s*EXPOSURE\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n          format_re = /^\\s*FORMAT=(\\S+)\\s*$/,\n          dimensions_re = /^\\s*\\-Y\\s+(\\d+)\\s+\\+X\\s+(\\d+)\\s*$/,\n          // RGBE format header struct\n      header = {\n        valid: 0,\n\n        /* indicate which fields are valid */\n        string: '',\n\n        /* the actual header string */\n        comments: '',\n\n        /* comments found in header */\n        programtype: 'RGBE',\n\n        /* listed at beginning of file to identify it after \"#?\". defaults to \"RGBE\" */\n        format: '',\n\n        /* RGBE format, default 32-bit_rle_rgbe */\n        gamma: 1.0,\n\n        /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */\n        exposure: 1.0,\n\n        /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */\n        width: 0,\n        height: 0\n        /* image dimensions, width/height */\n\n      };\n\n      if (buffer.pos >= buffer.byteLength || !(line = fgets(buffer))) {\n        return rgbe_error(rgbe_read_error, \"no header found\");\n      }\n      /* if you want to require the magic token then uncomment the next line */\n\n\n      if (!(match = line.match(magic_token_re))) {\n        return rgbe_error(rgbe_format_error, \"bad initial token\");\n      }\n\n      header.valid |= RGBE_VALID_PROGRAMTYPE;\n      header.programtype = match[1];\n      header.string += line + \"\\n\";\n\n      while (true) {\n        line = fgets(buffer);\n        if (false === line) break;\n        header.string += line + \"\\n\";\n\n        if ('#' === line.charAt(0)) {\n          header.comments += line + \"\\n\";\n          continue; // comment line\n        }\n\n        if (match = line.match(gamma_re)) {\n          header.gamma = parseFloat(match[1], 10);\n        }\n\n        if (match = line.match(exposure_re)) {\n          header.exposure = parseFloat(match[1], 10);\n        }\n\n        if (match = line.match(format_re)) {\n          header.valid |= RGBE_VALID_FORMAT;\n          header.format = match[1]; //'32-bit_rle_rgbe';\n        }\n\n        if (match = line.match(dimensions_re)) {\n          header.valid |= RGBE_VALID_DIMENSIONS;\n          header.height = parseInt(match[1], 10);\n          header.width = parseInt(match[2], 10);\n        }\n\n        if (header.valid & RGBE_VALID_FORMAT && header.valid & RGBE_VALID_DIMENSIONS) break;\n      }\n\n      if (!(header.valid & RGBE_VALID_FORMAT)) {\n        return rgbe_error(rgbe_format_error, \"missing format specifier\");\n      }\n\n      if (!(header.valid & RGBE_VALID_DIMENSIONS)) {\n        return rgbe_error(rgbe_format_error, \"missing image size specifier\");\n      }\n\n      return header;\n    },\n        RGBE_ReadPixels_RLE = function RGBE_ReadPixels_RLE(buffer, w, h) {\n      var data_rgba,\n          offset,\n          pos,\n          count,\n          byteValue,\n          scanline_buffer,\n          ptr,\n          ptr_end,\n          i,\n          l,\n          off,\n          isEncodedRun,\n          scanline_width = w,\n          num_scanlines = h,\n          rgbeStart;\n\n      if ( // run length encoding is not allowed so read flat\n      scanline_width < 8 || scanline_width > 0x7fff || // this file is not run length encoded\n      2 !== buffer[0] || 2 !== buffer[1] || buffer[2] & 0x80) {\n        // return the flat buffer\n        return new Uint8Array(buffer);\n      }\n\n      if (scanline_width !== (buffer[2] << 8 | buffer[3])) {\n        return rgbe_error(rgbe_format_error, \"wrong scanline width\");\n      }\n\n      data_rgba = new Uint8Array(4 * w * h);\n\n      if (!data_rgba.length) {\n        return rgbe_error(rgbe_memory_error, \"unable to allocate buffer space\");\n      }\n\n      offset = 0;\n      pos = 0;\n      ptr_end = 4 * scanline_width;\n      rgbeStart = new Uint8Array(4);\n      scanline_buffer = new Uint8Array(ptr_end); // read in each successive scanline\n\n      while (num_scanlines > 0 && pos < buffer.byteLength) {\n        if (pos + 4 > buffer.byteLength) {\n          return rgbe_error(rgbe_read_error);\n        }\n\n        rgbeStart[0] = buffer[pos++];\n        rgbeStart[1] = buffer[pos++];\n        rgbeStart[2] = buffer[pos++];\n        rgbeStart[3] = buffer[pos++];\n\n        if (2 != rgbeStart[0] || 2 != rgbeStart[1] || (rgbeStart[2] << 8 | rgbeStart[3]) != scanline_width) {\n          return rgbe_error(rgbe_format_error, \"bad rgbe scanline format\");\n        } // read each of the four channels for the scanline into the buffer\n        // first red, then green, then blue, then exponent\n\n\n        ptr = 0;\n\n        while (ptr < ptr_end && pos < buffer.byteLength) {\n          count = buffer[pos++];\n          isEncodedRun = count > 128;\n          if (isEncodedRun) count -= 128;\n\n          if (0 === count || ptr + count > ptr_end) {\n            return rgbe_error(rgbe_format_error, \"bad scanline data\");\n          }\n\n          if (isEncodedRun) {\n            // a (encoded) run of the same value\n            byteValue = buffer[pos++];\n\n            for (i = 0; i < count; i++) {\n              scanline_buffer[ptr++] = byteValue;\n            } //ptr += count;\n\n          } else {\n            // a literal-run\n            scanline_buffer.set(buffer.subarray(pos, pos + count), ptr);\n            ptr += count;\n            pos += count;\n          }\n        } // now convert data from buffer into rgba\n        // first red, then green, then blue, then exponent (alpha)\n\n\n        l = scanline_width; //scanline_buffer.byteLength;\n\n        for (i = 0; i < l; i++) {\n          off = 0;\n          data_rgba[offset] = scanline_buffer[i + off];\n          off += scanline_width; //1;\n\n          data_rgba[offset + 1] = scanline_buffer[i + off];\n          off += scanline_width; //1;\n\n          data_rgba[offset + 2] = scanline_buffer[i + off];\n          off += scanline_width; //1;\n\n          data_rgba[offset + 3] = scanline_buffer[i + off];\n          offset += 4;\n        }\n\n        num_scanlines--;\n      }\n\n      return data_rgba;\n    };\n\n    var RGBEByteToRGBFloat = function RGBEByteToRGBFloat(sourceArray, sourceOffset, destArray, destOffset) {\n      var e = sourceArray[sourceOffset + 3];\n      var scale = Math.pow(2.0, e - 128.0) / 255.0;\n      destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale;\n      destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale;\n      destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale;\n    };\n\n    var RGBEByteToRGBHalf = function RGBEByteToRGBHalf(sourceArray, sourceOffset, destArray, destOffset) {\n      var e = sourceArray[sourceOffset + 3];\n      var scale = Math.pow(2.0, e - 128.0) / 255.0;\n      destArray[destOffset + 0] = DataUtils.toHalfFloat(sourceArray[sourceOffset + 0] * scale);\n      destArray[destOffset + 1] = DataUtils.toHalfFloat(sourceArray[sourceOffset + 1] * scale);\n      destArray[destOffset + 2] = DataUtils.toHalfFloat(sourceArray[sourceOffset + 2] * scale);\n    };\n\n    var byteArray = new Uint8Array(buffer);\n    byteArray.pos = 0;\n    var rgbe_header_info = RGBE_ReadHeader(byteArray);\n\n    if (RGBE_RETURN_FAILURE !== rgbe_header_info) {\n      var w = rgbe_header_info.width,\n          h = rgbe_header_info.height,\n          image_rgba_data = RGBE_ReadPixels_RLE(byteArray.subarray(byteArray.pos), w, h);\n\n      if (RGBE_RETURN_FAILURE !== image_rgba_data) {\n        switch (this.type) {\n          case UnsignedByteType:\n            var data = image_rgba_data;\n            var format = RGBEFormat; // handled as THREE.RGBAFormat in shaders\n\n            var type = UnsignedByteType;\n            break;\n\n          case FloatType:\n            var numElements = image_rgba_data.length / 4 * 3;\n            var floatArray = new Float32Array(numElements);\n\n            for (var j = 0; j < numElements; j++) {\n              RGBEByteToRGBFloat(image_rgba_data, j * 4, floatArray, j * 3);\n            }\n\n            var data = floatArray;\n            var format = RGBFormat;\n            var type = FloatType;\n            break;\n\n          case HalfFloatType:\n            var numElements = image_rgba_data.length / 4 * 3;\n            var halfArray = new Uint16Array(numElements);\n\n            for (var j = 0; j < numElements; j++) {\n              RGBEByteToRGBHalf(image_rgba_data, j * 4, halfArray, j * 3);\n            }\n\n            var data = halfArray;\n            var format = RGBFormat;\n            var type = HalfFloatType;\n            break;\n\n          default:\n            console.error('THREE.RGBELoader: unsupported type: ', this.type);\n            break;\n        }\n\n        return {\n          width: w,\n          height: h,\n          data: data,\n          header: rgbe_header_info.string,\n          gamma: rgbe_header_info.gamma,\n          exposure: rgbe_header_info.exposure,\n          format: format,\n          type: type\n        };\n      }\n    }\n\n    return null;\n  },\n  setDataType: function setDataType(value) {\n    this.type = value;\n    return this;\n  },\n  load: function load(url, onLoad, onProgress, onError) {\n    function onLoadCallback(texture, texData) {\n      switch (texture.type) {\n        case UnsignedByteType:\n          texture.encoding = RGBEEncoding;\n          texture.minFilter = NearestFilter;\n          texture.magFilter = NearestFilter;\n          texture.generateMipmaps = false;\n          texture.flipY = true;\n          break;\n\n        case FloatType:\n          texture.encoding = LinearEncoding;\n          texture.minFilter = LinearFilter;\n          texture.magFilter = LinearFilter;\n          texture.generateMipmaps = false;\n          texture.flipY = true;\n          break;\n\n        case HalfFloatType:\n          texture.encoding = LinearEncoding;\n          texture.minFilter = LinearFilter;\n          texture.magFilter = LinearFilter;\n          texture.generateMipmaps = false;\n          texture.flipY = true;\n          break;\n      }\n\n      if (onLoad) onLoad(texture, texData);\n    }\n\n    return DataTextureLoader.prototype.load.call(this, url, onLoadCallback, onProgress, onError);\n  }\n});\nexport { RGBELoader };","map":{"version":3,"names":["DataTextureLoader","DataUtils","FloatType","HalfFloatType","LinearEncoding","LinearFilter","NearestFilter","RGBEEncoding","RGBEFormat","RGBFormat","UnsignedByteType","RGBELoader","manager","call","type","prototype","Object","assign","create","constructor","parse","buffer","RGBE_RETURN_FAILURE","rgbe_read_error","rgbe_write_error","rgbe_format_error","rgbe_memory_error","rgbe_error","rgbe_error_code","msg","console","error","RGBE_VALID_PROGRAMTYPE","RGBE_VALID_FORMAT","RGBE_VALID_DIMENSIONS","NEWLINE","fgets","lineLimit","consume","p","pos","i","len","s","chunkSize","chunk","String","fromCharCode","apply","Uint16Array","subarray","indexOf","byteLength","length","slice","RGBE_ReadHeader","line","match","magic_token_re","gamma_re","exposure_re","format_re","dimensions_re","header","valid","string","comments","programtype","format","gamma","exposure","width","height","charAt","parseFloat","parseInt","RGBE_ReadPixels_RLE","w","h","data_rgba","offset","count","byteValue","scanline_buffer","ptr","ptr_end","l","off","isEncodedRun","scanline_width","num_scanlines","rgbeStart","Uint8Array","set","RGBEByteToRGBFloat","sourceArray","sourceOffset","destArray","destOffset","e","scale","Math","pow","RGBEByteToRGBHalf","toHalfFloat","byteArray","rgbe_header_info","image_rgba_data","data","numElements","floatArray","Float32Array","j","halfArray","setDataType","value","load","url","onLoad","onProgress","onError","onLoadCallback","texture","texData","encoding","minFilter","magFilter","generateMipmaps","flipY"],"sources":["/Users/khuong/Downloads/avatar-homepage-demo-forked/node_modules/three/examples/jsm/loaders/RGBELoader.js"],"sourcesContent":["import {\n\tDataTextureLoader,\n\tDataUtils,\n\tFloatType,\n\tHalfFloatType,\n\tLinearEncoding,\n\tLinearFilter,\n\tNearestFilter,\n\tRGBEEncoding,\n\tRGBEFormat,\n\tRGBFormat,\n\tUnsignedByteType\n} from \"../../../build/three.module.js\";\n\n// https://github.com/mrdoob/three.js/issues/5552\n// http://en.wikipedia.org/wiki/RGBE_image_format\n\nvar RGBELoader = function ( manager ) {\n\n\tDataTextureLoader.call( this, manager );\n\n\tthis.type = UnsignedByteType;\n\n};\n\nRGBELoader.prototype = Object.assign( Object.create( DataTextureLoader.prototype ), {\n\n\tconstructor: RGBELoader,\n\n\t// adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html\n\n\tparse: function ( buffer ) {\n\n\t\tvar\n\t\t\t/* return codes for rgbe routines */\n\t\t\t//RGBE_RETURN_SUCCESS = 0,\n\t\t\tRGBE_RETURN_FAILURE = - 1,\n\n\t\t\t/* default error routine.  change this to change error handling */\n\t\t\trgbe_read_error = 1,\n\t\t\trgbe_write_error = 2,\n\t\t\trgbe_format_error = 3,\n\t\t\trgbe_memory_error = 4,\n\t\t\trgbe_error = function ( rgbe_error_code, msg ) {\n\n\t\t\t\tswitch ( rgbe_error_code ) {\n\n\t\t\t\t\tcase rgbe_read_error: console.error( \"RGBELoader Read Error: \" + ( msg || '' ) );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase rgbe_write_error: console.error( \"RGBELoader Write Error: \" + ( msg || '' ) );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase rgbe_format_error: console.error( \"RGBELoader Bad File Format: \" + ( msg || '' ) );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\tcase rgbe_memory_error: console.error( \"RGBELoader: Error: \" + ( msg || '' ) );\n\n\t\t\t\t}\n\n\t\t\t\treturn RGBE_RETURN_FAILURE;\n\n\t\t\t},\n\n\t\t\t/* offsets to red, green, and blue components in a data (float) pixel */\n\t\t\t//RGBE_DATA_RED = 0,\n\t\t\t//RGBE_DATA_GREEN = 1,\n\t\t\t//RGBE_DATA_BLUE = 2,\n\n\t\t\t/* number of floats per pixel, use 4 since stored in rgba image format */\n\t\t\t//RGBE_DATA_SIZE = 4,\n\n\t\t\t/* flags indicating which fields in an rgbe_header_info are valid */\n\t\t\tRGBE_VALID_PROGRAMTYPE = 1,\n\t\t\tRGBE_VALID_FORMAT = 2,\n\t\t\tRGBE_VALID_DIMENSIONS = 4,\n\n\t\t\tNEWLINE = \"\\n\",\n\n\t\t\tfgets = function ( buffer, lineLimit, consume ) {\n\n\t\t\t\tlineLimit = ! lineLimit ? 1024 : lineLimit;\n\t\t\t\tvar p = buffer.pos,\n\t\t\t\t\ti = - 1, len = 0, s = '', chunkSize = 128,\n\t\t\t\t\tchunk = String.fromCharCode.apply( null, new Uint16Array( buffer.subarray( p, p + chunkSize ) ) )\n\t\t\t\t;\n\t\t\t\twhile ( ( 0 > ( i = chunk.indexOf( NEWLINE ) ) ) && ( len < lineLimit ) && ( p < buffer.byteLength ) ) {\n\n\t\t\t\t\ts += chunk; len += chunk.length;\n\t\t\t\t\tp += chunkSize;\n\t\t\t\t\tchunk += String.fromCharCode.apply( null, new Uint16Array( buffer.subarray( p, p + chunkSize ) ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( - 1 < i ) {\n\n\t\t\t\t\t/*for (i=l-1; i>=0; i--) {\n\t\t\t\t\t\tbyteCode = m.charCodeAt(i);\n\t\t\t\t\t\tif (byteCode > 0x7f && byteCode <= 0x7ff) byteLen++;\n\t\t\t\t\t\telse if (byteCode > 0x7ff && byteCode <= 0xffff) byteLen += 2;\n\t\t\t\t\t\tif (byteCode >= 0xDC00 && byteCode <= 0xDFFF) i--; //trail surrogate\n\t\t\t\t\t}*/\n\t\t\t\t\tif ( false !== consume ) buffer.pos += len + i + 1;\n\t\t\t\t\treturn s + chunk.slice( 0, i );\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t},\n\n\t\t\t/* minimal header reading.  modify if you want to parse more information */\n\t\t\tRGBE_ReadHeader = function ( buffer ) {\n\n\t\t\t\tvar line, match,\n\n\t\t\t\t\t// regexes to parse header info fields\n\t\t\t\t\tmagic_token_re = /^#\\?(\\S+)$/,\n\t\t\t\t\tgamma_re = /^\\s*GAMMA\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n\t\t\t\t\texposure_re = /^\\s*EXPOSURE\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n\t\t\t\t\tformat_re = /^\\s*FORMAT=(\\S+)\\s*$/,\n\t\t\t\t\tdimensions_re = /^\\s*\\-Y\\s+(\\d+)\\s+\\+X\\s+(\\d+)\\s*$/,\n\n\t\t\t\t\t// RGBE format header struct\n\t\t\t\t\theader = {\n\n\t\t\t\t\t\tvalid: 0, /* indicate which fields are valid */\n\n\t\t\t\t\t\tstring: '', /* the actual header string */\n\n\t\t\t\t\t\tcomments: '', /* comments found in header */\n\n\t\t\t\t\t\tprogramtype: 'RGBE', /* listed at beginning of file to identify it after \"#?\". defaults to \"RGBE\" */\n\n\t\t\t\t\t\tformat: '', /* RGBE format, default 32-bit_rle_rgbe */\n\n\t\t\t\t\t\tgamma: 1.0, /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */\n\n\t\t\t\t\t\texposure: 1.0, /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */\n\n\t\t\t\t\t\twidth: 0, height: 0 /* image dimensions, width/height */\n\n\t\t\t\t\t};\n\n\t\t\t\tif ( buffer.pos >= buffer.byteLength || ! ( line = fgets( buffer ) ) ) {\n\n\t\t\t\t\treturn rgbe_error( rgbe_read_error, \"no header found\" );\n\n\t\t\t\t}\n\n\t\t\t\t/* if you want to require the magic token then uncomment the next line */\n\t\t\t\tif ( ! ( match = line.match( magic_token_re ) ) ) {\n\n\t\t\t\t\treturn rgbe_error( rgbe_format_error, \"bad initial token\" );\n\n\t\t\t\t}\n\n\t\t\t\theader.valid |= RGBE_VALID_PROGRAMTYPE;\n\t\t\t\theader.programtype = match[ 1 ];\n\t\t\t\theader.string += line + \"\\n\";\n\n\t\t\t\twhile ( true ) {\n\n\t\t\t\t\tline = fgets( buffer );\n\t\t\t\t\tif ( false === line ) break;\n\t\t\t\t\theader.string += line + \"\\n\";\n\n\t\t\t\t\tif ( '#' === line.charAt( 0 ) ) {\n\n\t\t\t\t\t\theader.comments += line + \"\\n\";\n\t\t\t\t\t\tcontinue; // comment line\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( match = line.match( gamma_re ) ) {\n\n\t\t\t\t\t\theader.gamma = parseFloat( match[ 1 ], 10 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( match = line.match( exposure_re ) ) {\n\n\t\t\t\t\t\theader.exposure = parseFloat( match[ 1 ], 10 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( match = line.match( format_re ) ) {\n\n\t\t\t\t\t\theader.valid |= RGBE_VALID_FORMAT;\n\t\t\t\t\t\theader.format = match[ 1 ];//'32-bit_rle_rgbe';\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( match = line.match( dimensions_re ) ) {\n\n\t\t\t\t\t\theader.valid |= RGBE_VALID_DIMENSIONS;\n\t\t\t\t\t\theader.height = parseInt( match[ 1 ], 10 );\n\t\t\t\t\t\theader.width = parseInt( match[ 2 ], 10 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ( header.valid & RGBE_VALID_FORMAT ) && ( header.valid & RGBE_VALID_DIMENSIONS ) ) break;\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! ( header.valid & RGBE_VALID_FORMAT ) ) {\n\n\t\t\t\t\treturn rgbe_error( rgbe_format_error, \"missing format specifier\" );\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! ( header.valid & RGBE_VALID_DIMENSIONS ) ) {\n\n\t\t\t\t\treturn rgbe_error( rgbe_format_error, \"missing image size specifier\" );\n\n\t\t\t\t}\n\n\t\t\t\treturn header;\n\n\t\t\t},\n\n\t\t\tRGBE_ReadPixels_RLE = function ( buffer, w, h ) {\n\n\t\t\t\tvar data_rgba, offset, pos, count, byteValue,\n\t\t\t\t\tscanline_buffer, ptr, ptr_end, i, l, off, isEncodedRun,\n\t\t\t\t\tscanline_width = w, num_scanlines = h, rgbeStart\n\t\t\t\t;\n\n\t\t\t\tif (\n\t\t\t\t\t// run length encoding is not allowed so read flat\n\t\t\t\t\t( ( scanline_width < 8 ) || ( scanline_width > 0x7fff ) ) ||\n\t\t\t\t\t// this file is not run length encoded\n\t\t\t\t\t( ( 2 !== buffer[ 0 ] ) || ( 2 !== buffer[ 1 ] ) || ( buffer[ 2 ] & 0x80 ) )\n\t\t\t\t) {\n\n\t\t\t\t\t// return the flat buffer\n\t\t\t\t\treturn new Uint8Array( buffer );\n\n\t\t\t\t}\n\n\t\t\t\tif ( scanline_width !== ( ( buffer[ 2 ] << 8 ) | buffer[ 3 ] ) ) {\n\n\t\t\t\t\treturn rgbe_error( rgbe_format_error, \"wrong scanline width\" );\n\n\t\t\t\t}\n\n\t\t\t\tdata_rgba = new Uint8Array( 4 * w * h );\n\n\t\t\t\tif ( ! data_rgba.length ) {\n\n\t\t\t\t\treturn rgbe_error( rgbe_memory_error, \"unable to allocate buffer space\" );\n\n\t\t\t\t}\n\n\t\t\t\toffset = 0; pos = 0; ptr_end = 4 * scanline_width;\n\t\t\t\trgbeStart = new Uint8Array( 4 );\n\t\t\t\tscanline_buffer = new Uint8Array( ptr_end );\n\n\t\t\t\t// read in each successive scanline\n\t\t\t\twhile ( ( num_scanlines > 0 ) && ( pos < buffer.byteLength ) ) {\n\n\t\t\t\t\tif ( pos + 4 > buffer.byteLength ) {\n\n\t\t\t\t\t\treturn rgbe_error( rgbe_read_error );\n\n\t\t\t\t\t}\n\n\t\t\t\t\trgbeStart[ 0 ] = buffer[ pos ++ ];\n\t\t\t\t\trgbeStart[ 1 ] = buffer[ pos ++ ];\n\t\t\t\t\trgbeStart[ 2 ] = buffer[ pos ++ ];\n\t\t\t\t\trgbeStart[ 3 ] = buffer[ pos ++ ];\n\n\t\t\t\t\tif ( ( 2 != rgbeStart[ 0 ] ) || ( 2 != rgbeStart[ 1 ] ) || ( ( ( rgbeStart[ 2 ] << 8 ) | rgbeStart[ 3 ] ) != scanline_width ) ) {\n\n\t\t\t\t\t\treturn rgbe_error( rgbe_format_error, \"bad rgbe scanline format\" );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// read each of the four channels for the scanline into the buffer\n\t\t\t\t\t// first red, then green, then blue, then exponent\n\t\t\t\t\tptr = 0;\n\t\t\t\t\twhile ( ( ptr < ptr_end ) && ( pos < buffer.byteLength ) ) {\n\n\t\t\t\t\t\tcount = buffer[ pos ++ ];\n\t\t\t\t\t\tisEncodedRun = count > 128;\n\t\t\t\t\t\tif ( isEncodedRun ) count -= 128;\n\n\t\t\t\t\t\tif ( ( 0 === count ) || ( ptr + count > ptr_end ) ) {\n\n\t\t\t\t\t\t\treturn rgbe_error( rgbe_format_error, \"bad scanline data\" );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( isEncodedRun ) {\n\n\t\t\t\t\t\t\t// a (encoded) run of the same value\n\t\t\t\t\t\t\tbyteValue = buffer[ pos ++ ];\n\t\t\t\t\t\t\tfor ( i = 0; i < count; i ++ ) {\n\n\t\t\t\t\t\t\t\tscanline_buffer[ ptr ++ ] = byteValue;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//ptr += count;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// a literal-run\n\t\t\t\t\t\t\tscanline_buffer.set( buffer.subarray( pos, pos + count ), ptr );\n\t\t\t\t\t\t\tptr += count; pos += count;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\t// now convert data from buffer into rgba\n\t\t\t\t\t// first red, then green, then blue, then exponent (alpha)\n\t\t\t\t\tl = scanline_width; //scanline_buffer.byteLength;\n\t\t\t\t\tfor ( i = 0; i < l; i ++ ) {\n\n\t\t\t\t\t\toff = 0;\n\t\t\t\t\t\tdata_rgba[ offset ] = scanline_buffer[ i + off ];\n\t\t\t\t\t\toff += scanline_width; //1;\n\t\t\t\t\t\tdata_rgba[ offset + 1 ] = scanline_buffer[ i + off ];\n\t\t\t\t\t\toff += scanline_width; //1;\n\t\t\t\t\t\tdata_rgba[ offset + 2 ] = scanline_buffer[ i + off ];\n\t\t\t\t\t\toff += scanline_width; //1;\n\t\t\t\t\t\tdata_rgba[ offset + 3 ] = scanline_buffer[ i + off ];\n\t\t\t\t\t\toffset += 4;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tnum_scanlines --;\n\n\t\t\t\t}\n\n\t\t\t\treturn data_rgba;\n\n\t\t\t};\n\n\t\tvar RGBEByteToRGBFloat = function ( sourceArray, sourceOffset, destArray, destOffset ) {\n\n\t\t\tvar e = sourceArray[ sourceOffset + 3 ];\n\t\t\tvar scale = Math.pow( 2.0, e - 128.0 ) / 255.0;\n\n\t\t\tdestArray[ destOffset + 0 ] = sourceArray[ sourceOffset + 0 ] * scale;\n\t\t\tdestArray[ destOffset + 1 ] = sourceArray[ sourceOffset + 1 ] * scale;\n\t\t\tdestArray[ destOffset + 2 ] = sourceArray[ sourceOffset + 2 ] * scale;\n\n\t\t};\n\n\t\tvar RGBEByteToRGBHalf = function ( sourceArray, sourceOffset, destArray, destOffset ) {\n\n\t\t\tvar e = sourceArray[ sourceOffset + 3 ];\n\t\t\tvar scale = Math.pow( 2.0, e - 128.0 ) / 255.0;\n\n\t\t\tdestArray[ destOffset + 0 ] = DataUtils.toHalfFloat( sourceArray[ sourceOffset + 0 ] * scale );\n\t\t\tdestArray[ destOffset + 1 ] = DataUtils.toHalfFloat( sourceArray[ sourceOffset + 1 ] * scale );\n\t\t\tdestArray[ destOffset + 2 ] = DataUtils.toHalfFloat( sourceArray[ sourceOffset + 2 ] * scale );\n\n\t\t};\n\n\t\tvar byteArray = new Uint8Array( buffer );\n\t\tbyteArray.pos = 0;\n\t\tvar rgbe_header_info = RGBE_ReadHeader( byteArray );\n\n\t\tif ( RGBE_RETURN_FAILURE !== rgbe_header_info ) {\n\n\t\t\tvar w = rgbe_header_info.width,\n\t\t\t\th = rgbe_header_info.height,\n\t\t\t\timage_rgba_data = RGBE_ReadPixels_RLE( byteArray.subarray( byteArray.pos ), w, h );\n\n\t\t\tif ( RGBE_RETURN_FAILURE !== image_rgba_data ) {\n\n\t\t\t\tswitch ( this.type ) {\n\n\t\t\t\t\tcase UnsignedByteType:\n\n\t\t\t\t\t\tvar data = image_rgba_data;\n\t\t\t\t\t\tvar format = RGBEFormat; // handled as THREE.RGBAFormat in shaders\n\t\t\t\t\t\tvar type = UnsignedByteType;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase FloatType:\n\n\t\t\t\t\t\tvar numElements = ( image_rgba_data.length / 4 ) * 3;\n\t\t\t\t\t\tvar floatArray = new Float32Array( numElements );\n\n\t\t\t\t\t\tfor ( var j = 0; j < numElements; j ++ ) {\n\n\t\t\t\t\t\t\tRGBEByteToRGBFloat( image_rgba_data, j * 4, floatArray, j * 3 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar data = floatArray;\n\t\t\t\t\t\tvar format = RGBFormat;\n\t\t\t\t\t\tvar type = FloatType;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase HalfFloatType:\n\n\t\t\t\t\t\tvar numElements = ( image_rgba_data.length / 4 ) * 3;\n\t\t\t\t\t\tvar halfArray = new Uint16Array( numElements );\n\n\t\t\t\t\t\tfor ( var j = 0; j < numElements; j ++ ) {\n\n\t\t\t\t\t\t\tRGBEByteToRGBHalf( image_rgba_data, j * 4, halfArray, j * 3 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar data = halfArray;\n\t\t\t\t\t\tvar format = RGBFormat;\n\t\t\t\t\t\tvar type = HalfFloatType;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tconsole.error( 'THREE.RGBELoader: unsupported type: ', this.type );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\twidth: w, height: h,\n\t\t\t\t\tdata: data,\n\t\t\t\t\theader: rgbe_header_info.string,\n\t\t\t\t\tgamma: rgbe_header_info.gamma,\n\t\t\t\t\texposure: rgbe_header_info.exposure,\n\t\t\t\t\tformat: format,\n\t\t\t\t\ttype: type\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t},\n\n\tsetDataType: function ( value ) {\n\n\t\tthis.type = value;\n\t\treturn this;\n\n\t},\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tfunction onLoadCallback( texture, texData ) {\n\n\t\t\tswitch ( texture.type ) {\n\n\t\t\t\tcase UnsignedByteType:\n\n\t\t\t\t\ttexture.encoding = RGBEEncoding;\n\t\t\t\t\ttexture.minFilter = NearestFilter;\n\t\t\t\t\ttexture.magFilter = NearestFilter;\n\t\t\t\t\ttexture.generateMipmaps = false;\n\t\t\t\t\ttexture.flipY = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FloatType:\n\n\t\t\t\t\ttexture.encoding = LinearEncoding;\n\t\t\t\t\ttexture.minFilter = LinearFilter;\n\t\t\t\t\ttexture.magFilter = LinearFilter;\n\t\t\t\t\ttexture.generateMipmaps = false;\n\t\t\t\t\ttexture.flipY = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase HalfFloatType:\n\n\t\t\t\t\ttexture.encoding = LinearEncoding;\n\t\t\t\t\ttexture.minFilter = LinearFilter;\n\t\t\t\t\ttexture.magFilter = LinearFilter;\n\t\t\t\t\ttexture.generateMipmaps = false;\n\t\t\t\t\ttexture.flipY = true;\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( onLoad ) onLoad( texture, texData );\n\n\t\t}\n\n\t\treturn DataTextureLoader.prototype.load.call( this, url, onLoadCallback, onProgress, onError );\n\n\t}\n\n} );\n\nexport { RGBELoader };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}